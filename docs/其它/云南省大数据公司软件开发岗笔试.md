## Java



### ConcurrentHashMap 与 HashTable 区别 从实现原理、线程安全、使用场景等方面简述



| 特性            | ConcurrentHashMap                                            | HashMap                                                      | HashTable                                                    |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现原理        | 数组 + 链表/红黑树                                           | 数组 + 链表<br/>数组+链表+红黑树(JDK8以后链表的长度超过8时，链表就会转换成红黑树) | 数组 + 链表                                                  |
| 线程安全        | 是（分段锁/CAS）                                             | 否                                                           | 是（全局锁）                                                 |
| 并发性能        | 高                                                           | 低                                                           | 低                                                           |
| 读写性能        | **读操作无锁**；写操作时，对某个段加锁，而不是整个表。因此，**读写性能都很高** | 写操作上是整体加锁的，多线程对 `HashMap` 进行写操作时存在竞争，性能相对较差 | 由于每次读写都要锁住整个表，所以 **读操作** 和 **写操作** 都会阻塞；读写性能差 |
| 允许 null 键/值 | 否                                                           | 是                                                           | 否                                                           |
| 适用场景        | 高并发读写（如缓存、计数器）<br/>需要原子性复合操作（如 `putIfAbsent()`、`merge()`）<br/>迭代期间不要求强一致性的场景 | 单线程或者线程安全要求不高的场景                             | 早期版本的线程安全集合类，适合在并发要求不高的小规模应用中使用 |
| 迭代器弱一致性  | 是                                                           | 否                                                           | 否                                                           |



#### ConcurrentHashMap 扩展

**ConcurrentHashMap 是 Java 中线程安全的高性能哈希表实现，专为高并发场景设计，支持多线程读写操作而无须外部同步机制。**‌ 其核心优势在于通过分段锁、CAS 操作和细粒度同步策略实现高效并发访问，相比 HashTable 和 Collections.synchronizedMap() 具有更高的吞吐量和扩展性。‌‌‌‌1

‌**核心特性与实现原理**‌

1. ‌**线程安全机制**‌。
   - ‌**JDK 1.7 分段锁**‌：将哈希表划分为多个 Segment（默认 16），每个段独立加锁，降低锁竞争范围。‌‌‌‌2
   - ‌**JDK 1.8 优化设计**‌
     1. 采用 `Node 数组 + 链表/红黑树` 结构，使用 `synchronized` 锁单个桶（链表头节点）和 CAS 操作保证原子性。‌‌‌‌3
     2. 当链表长度超过 8 且数组容量≥64 时，链表转为红黑树以提升查询效率。‌‌3‌‌4

‌**注意事项**‌

- ‌**版本差异**‌：JDK 1.8 的实现摒弃了 Segment 分段锁，锁粒度更细、并发性能更高。‌‌‌‌
- ‌**内存可见性**‌：通过 `volatile` 关键字保证 Node 值的可见性，避免脏读



### runable 与 callable区别

| 特性         | Runnable                          | Callable                                                     |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| 包           | java.lang                         | java.util.concurrent                                         |
| 方法         | run()                             | call()                                                       |
| 返回值       | 无                                | 有，类型由泛型指定                                           |
| 异常         | 不能抛出受检异常                  | 可以抛出受检异常                                             |
| 引入版本     | Java 1.0                          | Java 5.0                                                     |
| 使用方式     | Thread或ExecutorService.execute() | 只能使用ExecutorService.submit()<br/>future.get()获取执行结果 |
| 典型应用     | 简单异步任务                      | 需要结果的任务                                               |
| 是否可以取消 | 间接通过Thread                    | 通过Future.cancel()                                          |
| 性能开销     | 较低                              | 稍高                                                         |



### Nio核心方法简述，及如何使用Nio高效IO操作

**NIO的核心方法主要包括 Buffer 、 Channel 和 Selector** ‌。

**Buffer**

Buffer是NIO中的一个核心组件，它是一个容器，用于存储数据。Buffer主要有以下几个关键属性：

- ‌**capacity**‌：Buffer的容量，一旦创建，不能改变。
- ‌**limit**‌：Buffer的界限，表示Buffer中可操作的数据量。
- ‌**position**‌：下一个要操作的数据元素的位置。
- ‌**mark**‌：记录position的位置，可以通过调用mark()方法设置，通过reset()方法恢复。

Buffer的常用操作包括：

- ‌**flip()**‌：将limit设置为当前position的值，然后将position设置为0，用于将Buffer从写模式切换到读模式。
- ‌**clear()**‌：重置Buffer，将limit设置为capacity，position设置为0，用于清空Buffer。
- ‌**compact()**‌：将所有未读的数据拷贝到Buffer的起始处，然后设置position为未读数据的数量，主要用于非阻塞IO。



**Channel**

Channel是NIO中的另一个核心组件，它负责数据的传输。Channel主要有以下几个关键方法：

- ‌**read(Buffer)**‌：从Channel中读取数据到Buffer中。
- ‌**write(Buffer)**‌：将Buffer中的数据写入Channel中。
- ‌**close()**‌：关闭Channel。

Channel的分类包括：

- ‌**FileChannel**‌：用于文件操作。
- ‌**SocketChannel**‌：用于网络通信。
- ‌**ServerSocketChannel**‌：用于服务器端监听连接请求。



**Selector

Selector是NIO中的事件驱动机制，用于监听多个Channel的事件（如连接打开、数据到达等）。Selector的主要方法包括：

- ‌**select()**‌：监听所有注册的Channel的事件。
- ‌**selectedKeys()**‌：返回所有已注册且事件就绪的Channel集合。
- ‌**register(Channel, SelectionKey)**‌：将Channel注册到Selector上。
- ‌**unregister(SelectionKey)**‌：从Selector上注销Channel。

通过使用Selector，可以实现单线程处理多个Channel的高效IO操作，特别适用于高并发场景。



### Optional空值处理简述

**Optional 类是 Java 8 引入的容器类，用于处理可能为 null 的值**‌。其核心目标是显式处理空值场景，减少 NullPointerException 的发生，并提升代码的可读性和安全性。以下是关于 Optional 的使用要点：

‌**创建 Optional 实例**‌

1. ‌**严格非空**‌：使用 `Optional.of(T value)` 创建实例时，若传入值为 null 会抛出 `NullPointerException`。
2. ‌**兼容空值**‌：使用 `Optional.ofNullable(T value)` 允许传入 null 值（此时返回空的 Optional 实例），例如：

```java
Optional<String> opt = Optional.ofNullable(null); // 返回空的 Optional 实例
```

1. ‌**显式空值**‌：使用 `Optional.empty()` 创建表示“无值”的 Optional 实例。‌‌‌‌

‌**核心方法**‌

1. ‌**检查值是否存在**‌
   - `isPresent()`：返回布尔值表示值是否存在（存在为 true）。
   - `isEmpty()`（Java 11+）：若值不存在返回 true。‌‌
2. ‌**安全访问值**‌
   - `ifPresent(Consumer<T> consumer)`：若值存在则执行给定的操作（无返回值）。‌‌‌‌
   - `ifPresentOrElse(Consumer<T> onPresent, Runnable onEmpty)`：Java 9+ 提供二元响应逻辑。‌‌
3. ‌**默认值处理**‌
   - `orElse(T other)`：若值不存在返回默认值。‌‌
   - `orElseThrow(Supplier<? extends X> exceptionSupplier)`：若值不存在抛出自定义异常。‌‌‌‌
4. ‌**链式操作**‌：结合 `map()` 和 `flatMap()` 实现复杂的数据处理逻辑（例如：`userOptional.flatMap(User::getAddress).map(Address::getCity)`）。‌‌‌‌

‌**优势与场景应用**‌

- ‌**替代多层 null 检查**‌：避免冗长的 `if (obj != null)` 嵌套代码。‌‌
- ‌**明确空值语义**‌：通过 `Optional` 的方法强制调用方处理空值情况（例如：`loadConfig()` 方法返回 `Optional<Config>`）。‌‌‌‌
- ‌**结合 Stream API**‌：处理集合数据时自动过滤空值（例如：`users.stream().map(User::getLatestOrder).flatMap(Optional::stream)`）。‌‌‌‌

‌**注意事项**‌：`Optional` 仅针对 null 值有效，无法处理空字符串或其他非 null 的“空”状态



### 不需要`import`即可使用的包

`java.lang`



### 线程开始执行的方法

`start`方法

### volatile关键字

`volatile`是Java提供的一种轻量级的同步机制，用于确保变量的可见性和禁止指令重排序。与`synchronized`相比，`volatile`不会引起线程上下文的切换和调度，因此执行成本更低。

1. 保证变量的可见性

   在多线程环境下，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去主存中读取新值。

2. 禁止指令重排序

   `volatile`通过插入内存屏障来禁止处理器指令重排序，保证代码执行顺序与程序顺序一致。

#### volatile的实现原理
1. 内存屏障
    volatile通过以下内存屏障实现其功能：

  > LoadLoad屏障：确保前面的load操作先于后面的load操作
  >
  > LoadStore屏障：确保前面的load操作先于后面的store操作
  > StoreStore屏障：确保前面的store操作先于后面的store操作
  > StoreLoad屏障：确保前面的store操作先于后面的load操作

2. 缓存一致性协议
volatile底层通过缓存一致性协议（如MESI协议）来保证多核CPU下的数据一致性。

#### volatile的使用场景

1. 状态标志
2. 双重检查锁定(DCL)单例模式

#### volatile的局限性

1. **不保证原子性**：`volatile`不能保证复合操作的原子性，如`i++`。
2. **不替代锁**：对于需要互斥访问的场景，仍需使用`synchronized`或`Lock`。

#### volatile vs synchronized

| 特性         | volatile       | synchronized        |
| ------------ | -------------- | ------------------- |
| 原子性       | ×              | √                   |
| 可见性       | √              | √                   |
| 有序性       | √              | √                   |
| 线程阻塞     | ×              | √                   |
| 适用范围     | 变量           | 变量、方法、代码块  |
| 性能         | 更高           | 较低                |
| 典型应用     | 简单异步任务   | 需要结果的任务      |
| 是否可以取消 | 间接通过Thread | 通过Future.cancel() |
| 性能开销     | 较低           | 稍高                |



## Spring



### Spring Boot、Spring Cloud 常用注解



#### Spring Boot注解
1. @SpringBootApplication
   包含@Configuration、@EnableAutoConfiguration、@ComponentScan
    通常用在主类上。

2. @EnableAutoConfiguration
   让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。

3. @AutoConfiguration

   Spring Boot 用于标识 **自动配置类** 的核心注解。它明确标记一个类为 Spring Boot 自动配置逻辑的入口，用于根据项目依赖和配置条件，动态注册 Bean 或调整默认行为

4. @AutoConfigureAfter

5. @AutoConfigureBefore

6. @AutoConfigureOrder

7. @EnableConfigurationProperties

8. @ConfigurationProperties
   Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。 你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：

```JAVA
@Component
@ConfigurationProperties(prefix="connection")
public class ConnectionSettings { 

@NotNull
private InetAddress remoteAddress;
// ... getters and setters
}
```



#### Spring Cloud 注解

1. @EnableEurekaClient 配置本应用将使用服务注册和服务发现，注意：注册和发现用这个注解。 
2. @Import 导入其他配置类 
3. @ImportResource用来 加载xml配置文件 
4. @RefreshScope　如果代码中需要动态刷新配置，在需要的类上加上该注解就行。但某些复杂的注入场景下，这个注解使用不当，配置可能仍然不动态刷新; 
5. @LoadBalanced 开启客户端[负载均衡](https://cloud.tencent.com/product/clb?from_column=20065&from=20065) @WebAppConfiguration 开启Web 应用的配置，用于模拟ServletContext @RibbonClient，这个注解用来为负载均衡客户端做一些自定义的配置，可以进一步配置或自定义从哪里获取服务端列表、负载均衡策略、Ping也就是服务鉴活策略等等
6. **@EnableEurekaServer**： 用于开启Eureka[服务注册中心](https://cloud.tencent.com/product/rcc?from_column=20065&from=20065)的支持。标注在主类上，表示当前应用是一个Eureka服务注册中心。 
7.  **@EnableDiscoveryClient**： 让当前应用注册到Eureka Server，从而使服务消费者能够找到。标注在主类上，表示当前应用需要注册到服务注册中心，并且可以发现其他服务。 
8.  **@EnableCircuitBreaker** / **@EnableHystrix**： 开启Hystrix断路器功能，用于处理分布式系统中的故障和延迟，增强系统的弹性。注意，随着Hystrix项目的停止维护，Spring Cloud现在推荐使用其他替代方案，如Resilience4j。 
9.  **@EnableFeignClients**： 开启Feign的支持，Feign是一个声明式的Web Service客户端，使得编写HTTP客户端变得更简单。标注在主类或配置类上，用于扫描和创建Feign客户端的代理。 
10.  **@FeignClient**： 标注在接口上，指定创建一个Feign客户端的详细信息，包括服务ID、URL等。通常与@EnableFeignClients一起使用。 
11.  **@LoadBalanced**： 标注在RestTemplate Bean上，表示开启客户端的负载均衡功能。这样，当从Eureka Server获取到服务提供者的多个实例时，能够均衡地分配请求。 
12.  **@EnableZuulProxy**： 开启Zuul代理的支持，Zuul是一个基于Netflix开源的API网关，提供了动态路由、监控、弹性、安全等功能。标注在主类上，表示当前应用将作为API网关使用。 
13.  **@RibbonClient**： 用于自定义Ribbon客户端的配置。Ribbon是一个客户端[负载均衡器](https://cloud.tencent.com/product/clb?from_column=20065&from=20065)，它提供了对HTTP请求的控制，包括服务实例的选择策略等。通常与@LoadBalanced一起使用。 
14.  **@RefreshScope**： 当配置发生变化时，标记了@RefreshScope的Bean会进行刷新，重新加载配置。这对于动态刷新配置非常有用，尤其是在使用Spring Cloud Config时。 
15.  **@HystrixCommand**： 用于声明一个方法需要使用Hystrix断路器来包装。当调用该方法时，如果发生异常或超时，Hystrix会触发相应的回退逻辑。同样地，随着Hystrix的停止维护，开发者可能需要考虑其他替代方案。 
16.  **@EnableConfigServer**： 用于开启Spring Cloud Config Server的支持。标注在主类上，表示当前应用将作为配置服务器，提供外部化配置给其他微服务。 
17.  **@SentinelResource**： 如果你在使用阿里巴巴的Sentinel作为熔断器和限流器，那么这个注解将会很有用。它用于标注在需要保护的方法上，当该方法调用出现问题时（如超时、异常），Sentinel会根据配置进行熔断或限流。 
18.  **@GatewayFilter** 和 **@GlobalFilter**： 在使用Spring Cloud Gateway作为API网关时，这两个注解用于定义过滤器。@GatewayFilter用于定义针对特定路由的过滤器，而@GlobalFilter用于定义全局过滤器，应用于所有路由。 
19.  **@StreamListener**： 在使用Spring Cloud Stream进行消息驱动微服务开发时，这个注解用于标注方法，表示该方法是一个消息监听器，当接收到指定通道的消息时会被调用。注意，随着Spring Cloud Stream的发展，新的函数式编程模型（使用Java的Function、Consumer等接口）也逐渐成为推荐的使用方式。 
20.  **@RefreshEndpoint** 和 **@RestartEndpoint**： 这两个注解用于暴露端点，允许通过HTTP请求来刷新配置或重启应用。然而，请注意这些端点可能会暴露敏感操作，因此在使用时应谨慎考虑安全性

#### Spring 注解

1. @Qualifier 如果一个接口有多个实现，那么注入时候加上唯一标示 

   当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用

2. @Autowired bean注入

3. @Repository
   用于标注数据访问组件，即DAO组件。

4. @Service
   用于标注业务层组件。

5. @Controller 控制层，里面有多个连接

6. @RestController
   用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody。

7. @ResponseBody
   表示该方法的返回结果直接写入HTTP response body中
    一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。

8. @Component
   泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

9. @ComponentScan
   组件扫描。个人理解相当于context:component-scan，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。

10. @Configuration
    指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。

11. @Bean
    相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。

12. @RequestMapping
    RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
    该注解有六个属性：

    > params:指定request中必须包含某些参数值是，才让该方法处理。
    >  headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。
    >  value:指定请求的实际地址，指定的地址可以是URI Template 模式
    >  method:指定请求的method类型， GET、POST、PUT、DELETE等
    >  consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;
    >  produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回

13. @RequestParam
    用在方法的参数前面。
     `@RequestParam String a =request.getParameter("a")`
14. @PathVariable
    路径变量。参数与大括号里的名字一样要相同。

```JAVA
RequestMapping("user/get/mac/{macAddress}")
public String getByMacAddress(@PathVariable String macAddress){ 

　　//do something;
}
```

16. @Profiles
    Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。
     任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。

```JAVA
@Configuration
@Profile("prod")
public class ProductionConfiguration { 

    // ...

}
```

17. @ControllerAdvice
    包含@Component。可以被扫描到。
     统一处理异常。
18. @ExceptionHandler（Exception.class）

​	用在方法上面表示遇到这个异常就执行以下方法

19. @Component定义其它组件（比如访问外部服务的组件）
20. @ModelAttribute 一般用于controller层，呗注解的方法会在所以mapping执行之前执行，并且可以绑定参数到Model model里面。 
21. @Transactional （readOnly=true）注解式事务 @TransactionalEventListener用于配置事务的回调方法，可以在事务提交前、提交后、完成后以及回滚后几个阶段接受回调事件。 
22. @Value（“${}”）可以注入properties里面的配置项 
23. @InitBinder 一般用于controller 可以将所以form 讲所有传递进来的string 进行html编码，防止xss攻击，比如可以将字符串类型的日期转换成date类型 
24. @EnableCaching 注解自动化配置合适的缓存管理器。 
25. @EnableWebSecurity 注解开启spring security的功能，集成websercrityconfigureadapter。 
26. @CrossOrigin 可以处理跨域请求，让你能访问不是一个域的文件; 



#### 常用于Spring项目的Java自带注解

1. @Resource bean的注入
2. @PostConstruct 在Spring项目中用于标记Spring项目启动后执行的方法



#### @Resource 与 @Autowired 

共同点：@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。 不同点： @Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。 



## 数据库

### 事务隔离级别 可重复读是什么

**【读已提交】**：是一种隔离级别，可确保读取当前已提交的任何数据。 它只是限制读者看到任何中间的、未提交的、“脏”的阅读。 它不承诺如果事务重新发出读取，将找到相同的数据，数据在读取后可以自由更改。

**【可重复读】**：是更高的隔离级别，即除了保证【读已提交】级别之外，还保证读到的任何数据都不能被改变，即：如果事务再次读到同样的数据，就会发现之前读到的数据在原地，不变 ，并且可以阅读。

**【序列化】**：提供了更强大的保证：除了所有可重复读取保证之外，它还保证后续读取不会看到新数据。

- 幻读：说的是存不存在的问题：原来不存在的,现在存在了,则是幻读 （ 对应：Insert 、Delete ）
- 不可重复读：说的是变没变化的问题：原来是A,现在却变为了B,则为不可重复读（ 对应：Update ）

从数据库实现上去理解：幻读是表锁，不可重复读是行锁。



|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | ✔    | ✔          | ✔    |
| 读已提交 | ✘    | ✔          | ✔    |
| 可重复读 | ✘    | ✘          | ✔    |
| 序列化   | ✘    | ✘          | ✘    |



## 程序设计

### 无重复字符的最长子串

[LCR 016. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/wtcaE1/description/)
